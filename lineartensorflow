import * as tf from '@tensorflow/tfjs-node';

// 1. Define the Data Interface
interface IntradayData {
    open: number;
    high: number;
    low: number;
    close: number;
    volume: number;
}

// 2. Mock Intraday Training Data (Replace with your actual API data)
const rawData: IntradayData[] = [
    { open: 100.0, high: 101.5, low: 99.8, close: 101.2, volume: 150000 },
    { open: 101.2, high: 102.0, low: 100.5, close: 101.8, volume: 160000 },
    { open: 101.8, high: 103.1, low: 101.5, close: 102.9, volume: 180000 },
    { open: 102.9, high: 103.5, low: 102.5, close: 102.6, volume: 170000 },
    { open: 102.6, high: 103.0, low: 102.0, close: 102.8, volume: 165000 },
    // ... more data points
];

/**
 * Trains a simple linear regression model to predict the closing price 
 * based on the opening price.
 */
async function trainIntradayModel(data: IntradayData[]) {
    // 3. Prepare Data for TensorFlow
    // In this simple example, 'open' is the feature (X) and 'close' is the label (Y)
    const xs = data.map(d => d.open, d. high, d.low, d.close);
    const ys = data.map(d => d.close);

    const inputs = tf.tensor2d(xs, [xs.length, 1]); // Feature tensor (N samples, 1 feature)
    const labels = tf.tensor2d(ys, [ys.length, 1]); // Label tensor (N samples, 1 label)

    // 4. Define the Model Architecture (Simple Linear Model: y = mx + b)
    const model = tf.sequential();
    model.add(tf.layers.dense({ units: 1, inputShape: [1] }));

    // 5. Compile the Model
    model.compile({
        optimizer: tf.train.sgd(0.0001), // Stochastic Gradient Descent optimizer with a learning rate
        loss: 'meanSquaredError',      // Common loss function for regression
    });

    console.log('Starting model training...');
    
    // 6. Train the Model
    const history = await model.fit(inputs, labels, {
        epochs: 50, // Number of times to iterate over the data
        callbacks: {
            onEpochEnd: (epoch, logs) => {
                // Console log loss every 10 epochs
                if (epoch % 10 === 0) {
                    console.log(`Epoch ${epoch}: Loss = ${logs?.loss.toFixed(6)}`);
                }
            }
        }
    });

    console.log('Training complete.');
    // Clean up tensors from memory
    inputs.dispose();
    labels.dispose();
    
    return model;
}

/**
 * Predicts the closing price for a new opening price.
 */
function predictPrice(model: tf.Sequential, newOpenPrice: number): number {
    const inputTensor = tf.tensor2d([newOpenPrice], [1, 1]); // New input
    const predictionTensor = model.predict(inputTensor) as tf.Tensor;
    
    const prediction = predictionTensor.dataSync()[0];
    
    // Clean up tensors from memory
    inputTensor.dispose();
    predictionTensor.dispose();

    return prediction;
}

// 7. Execution Logic
async function runStrategy() {
    try {
        const trainedModel = await trainIntradayModel(rawData);

        // --- Intraday Strategy Simulation ---
        
        // Use the model to predict the closing price for a new data point
        const currentOpenPrice = 103.0; // Assume this is the current opening price of the asset
        
        const predictedClose = predictPrice(trainedModel, currentOpenPrice);

        console.log(`\n--- Strategy Output ---`);
        console.log(`Current Open Price: $${currentOpenPrice.toFixed(2)}`);
        console.log(`Predicted Close Price: $${predictedClose.toFixed(2)}`);

        // Simple Decision Logic: If predicted close is higher than current open, suggest a 'BUY'
        if (predictedClose > currentOpenPrice * 1.001) { // 0.1% buffer
            console.log(`**Decision:** ðŸš€ BUY - Prediction is significantly higher than open.`);
        } else if (predictedClose < currentOpenPrice * 0.999) { // 0.1% buffer
            console.log(`**Decision:** ðŸ“‰ SELL/SHORT - Prediction is significantly lower than open.`);
        } else {
            console.log(`**Decision:** ðŸŸ¡ HOLD - Prediction is too close to the open price.`);
        }

        // Dispose of the model after use
        trainedModel.dispose();
        
    } catch (error) {
        console.error("An error occurred during the ML process:", error);
    }
}

runStrategy();
